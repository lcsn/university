<?xml version="1.0" encoding="UTF-8"?>
<html lang="de" xmlns="http://www.w3.org/1999/xhtml"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
	xmlns:f="http://xmlns.jcp.org/jsf/core">
<h:head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<h:outputStylesheet name="css/map.css" />
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" />
	<!--
	<script type="text/javascript" src="js/vendor/jquery-1.10.2.min.js" />
	<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
	<script src="modernizr.min.js"></script>
	-->
	<script type="text/javascript">
				
		$(document).ready(function(){

			initZgame();
			
		})

		var mapCanvas;
		var mapContext;

		var rows;
		var cols;
		var type;
		var fSize;
		var dir;

		var markedZgameField;
		var selectedZgameField;
		
		function update() {
			mapContext.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
			
			rows = $("#rowsIn").val();
			cols = $("#colsIn").val();
			type = $("select[name='type'] option:selected").val();
			fSize = $("#fSize").val();
			dir = $("select[name='direction'] option:selected").val();
			markedZgameField = null;
			selectedZgameField = null;
			//alert(rows+" x "+cols+", "+(type==0?'flat':'pointy') + ", " + fSize);

			initZgame();
		}
		
		function initZgame() {
			mapCanvas = $("#mapCanvas")[0];
			mapContext = mapCanvas.getContext("2d");

			mapCanvas.addEventListener("mousemove", onMouseMove, false);
			mapCanvas.addEventListener("click", onMouseClick, false);

			mapContext.fillStyle   = '#fff';
			mapContext.strokeStyle = '#000';
			mapContext.lineWidth   = 1;

			zgameMap = new ZgameMap((fSize==null?50:fSize), (rows==null?5:rows), (cols==null?5:cols), 0, 0, (type==null?0:type), (dir==null?0:dir));
			zgameMap.draw(mapContext);
			
		}

		function onMouseClick(e) {
			var rect = mapCanvas.getBoundingClientRect();
			var x = e.clientX - rect.left;
			var y = e.clientY - rect.top;
			var result = zgameMap.findField(x, y);
			var zgameField = zgameMap.findField(x, y);
			if (zgameField != null) {
				if(selectedZgameField == null) {
					selectedZgameField = zgameField;
				}
				if(zgameField.gridX != selectedZgameField.gridX || zgameField.gridY != selectedZgameField.gridY) {
					selectedZgameField.unselect(mapContext);
					selectedZgameField = zgameField;
				}
				selectedZgameField.select(mapContext);
				
				var neighbors = zgameMap.getNeighbors(zgameField.gridX, zgameField.gridY, 1);
				for(var i = 0; i &lt; neighbors.length; i++) {
					neighbors[i].select(mapContext);
				}
			}
		}
		
		function onMouseMove(e) {
			var rect = mapCanvas.getBoundingClientRect();
			var x = e.clientX - rect.left;
			var y = e.clientY - rect.top;
			var message0 = '<b>Mouse position:</b> ' + Math.floor(x) + ', ' + Math.floor(y);
	        writeCoords(message0);
			var zgameField = zgameMap.findField(x, y);
			if (zgameField != null) {
				if(markedZgameField == null) {
					markedZgameField = zgameField;
				}
				if(zgameField.gridX != markedZgameField.gridX || zgameField.gridY != markedZgameField.gridY) {
					markedZgameField.unmark(mapContext);
					markedZgameField = zgameField;
				}
				zgameField.mark(mapContext);
				var message1 = '<b>Hex position:</b> ' + zgameField.gridX + ', ' + zgameField.gridY;// + ', ' + result.z;
				writeHexCoords(message1);
			}
		}

		function ZgameMap(aFieldSize, aWidth, aHeight, aLeft, aTop, aType, aDir) {

			var tiledMap = new Array();

			var type = aType;
			var dir = aDir;
			var fieldSize = aFieldSize;
			var height = aHeight;
			var width = aWidth;

			var left = aLeft;
			var top = aTop;
			
			var a = fieldSize/4;
			var h = fieldSize/4*2;
			
			var hexHeight;
			var hexWidth;
			var	hDistance;
			var	vDistance;

			//pointy top
			var neighbor_odd_r = [ [ [-1, -1], [0, -1], [1, 0], [0, 1], [-1, 1], [-1, 0] ], [ [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 0] ] ];
			var neighbor_even_r = [ [ [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 0] ], [ [-1, -1], [0, -1], [1, 0], [0, 1], [-1, 1], [-1, 0] ] ];
			//flat top
			var neighbor_odd_q = [ [ [-1, -1], [0, -1], [1, -1], [1, 0], [0, 1], [-1, 0] ], [ [-1, 0], [0, -1], [1, 0], [1, 1], [0, 1], [-1, 1] ] ];
			var neighbor_even_q = [ [ [-1, 0], [0, -1], [1, 0], [1, 1], [0, 1], [-1, 1] ], [ [-1, -1], [0, -1], [1, -1], [1, 0], [0, 1], [-1, 0] ] ];
			
			if(type == 1) {
				//pointy top
				hexHeight = a*2;
				hexWidth = Math.sqrt(3)/2*hexHeight;
				hDistance = hexWidth;
				vDistance = 0.75*hexHeight;
			}
			else if(type == 0) {
				//flat top
				hexWidth = a * 2;
				hexHeight = Math.sqrt(3)/2*hexWidth;
				vDistance = hexHeight;
				hDistance = 0.75*hexWidth;
			}
			else {
				// error
			}

			for(var i = 0; i &lt; height; i++) {
				tiledMap[i] = new Array();
				for(var j = 0; j &lt; width; j++) {
					if(type == 1) {
						//pointy top
						if (j%2 == dir) { // Offset every other row to give tessallation
							tiledMap[i][j] = new ZgameField(fieldSize, i, j, i*hDistance*2, j*vDistance*2, 1);
						} else {
							tiledMap[i][j] = new ZgameField(fieldSize, i, j, i*hDistance*2+hDistance, j*vDistance*2, 1);
						}
					}
					else if(type == 0) {
						//flat top
						if (i%2 == dir) { // Offset every other row to give tessallation
							tiledMap[i][j] = new ZgameField(fieldSize, i, j, i*hDistance*2, j*vDistance*2, 0);
						} else {
							tiledMap[i][j] = new ZgameField(fieldSize, i, j, i*hDistance*2, j*vDistance*2+vDistance, 0);
						}
					}
					else {
						// error
					}
				}
			}

			this.draw = function(context) {
				for(var i = 0; i &lt; height; i++) {
					for(var j = 0; j &lt; width; j++) {
						tiledMap[i][j].draw(context);
					}
				}
			}

			this.findField = function(x, y) {
				var result = null;

				//var pI = Math.floor(x/fieldSize);
				//var pJ = Math.floor(y/fieldSize);
				//ry = (rx+rz)*(-1);
				
				//alert(pI+", "+pJ);
				
				//var message = '<b>Selection offset:</b> ' + pI + ', ' + pJ;
				//writeSelectionOffset(message);
				
				for(var i = 0; i &lt; height; i++) {
					for(var j = 0; j &lt; width; j++) {
						if (tiledMap[i][j].contains(x, y))  {
							result = tiledMap[i][j];
							result.gridX = i;
							result.gridY = j;
							//return result;
						}
					}
				}
				return result;
			}

			/*
			this.getNeighborRecursive = function(q, r, d, direction, i) {
				if(d > 0) {
										
					getNeighborRecursive(q, r, d-1, direction, i+1);
				}
			}
			*/

			this.getNeighbor = function(d, q, r) {
				alert(width+", "+height);
				var n_fields = new Array();
				var j = 0;
				for (var i = 0; i &lt; 6; i++) {
					var dI = d[i];
					var qI = q+dI[0];
					var rI = r+dI[1];
					if((-1 &lt; qI &amp;&amp; qI &lt; height) &amp;&amp; (-1 &lt; rI &amp;&amp; rI &lt; width)) {
						//alert(qI+", "+rI);
						n_fields[j] = tiledMap[qI][rI];
						j++
					}
				}
				return n_fields;
			}
			
			this.getNeighbors = function(q, r, d) {

				var j = 0;
				var parity;
				var fields;

				if(type == 1) {
					//pointy top
					parity = r &amp; 1;
					alert(parity);
					//var d0, d1, d2, d3, d4, d5;
					if(dir == 0) {
						fields = this.getNeighbor(neighbor_odd_r[parity], q, r);
						/*
						d0 = neighbor_odd_r[parity][0]
						d1 = neighbor_odd_r[parity][1]
						d2 = neighbor_odd_r[parity][2]
						d3 = neighbor_odd_r[parity][3]
						d4 = neighbor_odd_r[parity][4]
						d5 = neighbor_odd_r[parity][5]
						*/
					}
					else {
						fields = this.getNeighbor(neighbor_even_r[parity], q, r);
						/*
						d0 = neighbor_even_r[parity][0]
						d1 = neighbor_even_r[parity][1]
						d2 = neighbor_even_r[parity][2]
						d3 = neighbor_even_r[parity][3]
						d4 = neighbor_even_r[parity][4]
						d5 = neighbor_even_r[parity][5]
						*/
					}
				}
				else if(type == 0) {
					//flat top
					parity = q &amp; 1;
					alert(parity);
					if(dir == 0) {
						fields = this.getNeighbor(neighbor_odd_q[parity], q, r);
						/*
						d0 = neighbor_odd_q[parity][0]
						d1 = neighbor_odd_q[parity][1]
						d2 = neighbor_odd_q[parity][2]
						d3 = neighbor_odd_q[parity][3]
						d4 = neighbor_odd_q[parity][4]
						d5 = neighbor_odd_q[parity][5]
						*/
					}
					else {
						fields = this.getNeighbor(neighbor_even_q[parity], q, r);
						/*
						d0 = neighbor_even_q[parity][0]
						d1 = neighbor_even_q[parity][1]
						d2 = neighbor_even_q[parity][2]
						d3 = neighbor_even_q[parity][3]
						d4 = neighbor_even_q[parity][4]
						d5 = neighbor_even_q[parity][5]
						*/
					}
				}
				else {
					// error
				}
				
				/*
				if(type == 1) {
					//pointy top
					 parity = r &amp; 1;
					 if(parity == dir) {
						//odd
						fields[0] = tiledMap[q-1][r-1];
						fields[1] = tiledMap[q][r-1];
						fields[2] = tiledMap[q+1][r];
						fields[3] = tiledMap[q][r+1];
						fields[4] = tiledMap[q-1][r+1];
						fields[5] = tiledMap[q-1][r];
					}
					else {
					 	//even
						fields[0] = tiledMap[q][r-1];
						fields[1] = tiledMap[q+1][r-1];
						fields[2] = tiledMap[q+1][r];
						fields[3] = tiledMap[q+1][r+1];
						fields[4] = tiledMap[q][r+1];
						fields[5] = tiledMap[q-1][r];
					}				
				}
				else if(type == 0) {
					//flat top
					 parity = q &amp; 1;
					 if(parity == dir) {
							//odd
						fields[0] = tiledMap[q-1][r-1];
						fields[1] = tiledMap[q][r-1];
						fields[2] = tiledMap[q+1][r-1];
						fields[3] = tiledMap[q+1][r];
						fields[4] = tiledMap[q][r+1];
						fields[5] = tiledMap[q-1][r];
					}
					else {
					 	//even
						fields[2] = tiledMap[q+1][r];
						fields[0] = tiledMap[q][r-1];
						fields[3] = tiledMap[q+1][r+1];
						fields[4] = tiledMap[q][r+1];
						fields[5] = tiledMap[q-1][r];
						fields[1] = tiledMap[q-1][r+1];
					}
				}
				else {
					// error
				}
				*/
				//alert(parity);
				
				/*
				for (var i = 0; i &lt; 6; i++) {
					var d = neighbors[parity][i];
					var qN = q + d[0];
					var rN = r + d[1];
					if((qN > 0 &amp;&amp; qN &lt;= width) &amp;&amp; (rN > 0 &amp;&amp; rN &lt;= height)) {
						fields[j] = tiledMap[qN][rN];
						j++;
					}			
				}
				return fields;
				*/

				return fields;
				
			}

		}
			
		function ZgameField(aSize, aQ, aR, aXOffset, aYOffset, aType) {

			var marked = false;
			var selected = false;
			
			var type = aType;
			var size = aSize;

			var a = size/4;

			var xOffset = aXOffset;
			var yOffset = aYOffset;

			var q = aQ;
			var r = aR;
			
			var x = aQ;
			var z = aR;
			var y = (x+z)*(-1);
			
			var center_x;
			var center_y;
			var center_z;

			this.draw = function(context) {
				context.beginPath();

				for (var i = 0; i &lt; 6; i++) {
					var angle;
					if(type == 1) {
						//pointy
						angle = 2 * Math.PI / 6 * (i + 0.5);
					}
					else if(type == 0) {
						//flat
						angle = 2 * Math.PI / 6 * (i);
					}
					else {
						// error
					}
					var x_i = xOffset + 2*a * Math.cos(angle) + 2*a;
	    			var y_i = yOffset + 2*a * Math.sin(angle) + 2*a;
					if (i==0){
						context.moveTo(x_i, y_i);
						if(type == 1) {
							//pointy
							center_x = x_i - (a*Math.sqrt(3));
							center_z = y_i - a;
						}
						else if(type == 0) {
							//flat
							center_x = x_i - 2*a;
							center_z = y_i;
						}
						else {
							// error
						}
						center_y = (center_x+center_z)*(-1);
					}
					else {
						context.lineTo(x_i, y_i);
					}
				}
				context.closePath();
				
				context.strokeStyle = "#000";
				if(selected) {
					context.beginPath();
					context.arc(center_x, center_z, (size/2*Math.sqrt(3)/2)-2, 0, 2 * Math.PI, false);
					context.strokeStyle = "#0f0";
					context.lineWidth = 2;
					context.stroke();	
				}
				else if(marked) {
					context.beginPath();
					context.arc(center_x, center_z, (size/2*Math.sqrt(3)/2)-2, 0, 2 * Math.PI, false);
					context.strokeStyle = "#f00";
					context.lineWidth = 2;
					context.stroke();
				}
				context.fillStyle = "white";
				context.fill();
				context.stroke();

				/*
				context.save();
				context.font = '16pt Calibri';
				context.lineWidth = 2;
				context.strokeStyle = 'black';
				var rx, ry, rz;
				rx = Math.floor(center_x/size);
				rz = Math.floor(center_z/size);
				ry = (rx+rz)*(-1);
				context.strokeText(rx+"|"+ry+"|"+rz, center_x-60, center_z-10);
				context.strokeText(Math.floor(center_x)+"|"+Math.floor(center_y)+"|"+Math.floor(center_z), center_x-60, center_z+10);
				//context.strokeText(x+"|"+y+"|"+z, center_x-60, center_z+30);
				context.strokeText(x+"|"+z, center_x-60, center_z+50);
				context.restore();
				*/
			}

			this.mark = function(context) {
				if(!marked &amp;&amp; !selected) {
					context.save();
					context.strokeStyle = '#f00';
					context.lineWidth = 3;
					marked = true;
					this.draw(context);
					context.restore();
				}
			}
			
			this.unmark = function(context) {
				if(marked &amp;&amp; !selected) {
					marked = false;
					this.draw(context);
				}
			}

			this.select = function(context) {
				if(!selected) {
					context.save();
					context.strokeStyle = '#0f0';
					context.lineWidth = 3;
					selected = true;
					this.draw(context);
					context.restore();
				}
			}

			this.unselect = function(context) {
				if(selected) {
					selected = false;
					marked = false;
					this.draw(context);
				}
			}
			
			this.contains = function(x, y) {
				var result = false;

				var dx = Math.abs(x)-Math.abs(center_x);
				var dy = Math.abs(y)-Math.abs(center_z);

				var dist = Math.sqrt(dx*dx+dy*dy);
				var ir = size/2*Math.sqrt(3)/2; 
				//alert(q+"|"+((q+r)*(-1))+"|"+r+", dx: " + dx + ", dy:" + dy + ", dist: " + dist + ", radius: " + ir);

				if(ir>dist) {
					result = true;
				}

				return result;			
			}
			
		}

		function writeSelectionOffset(message) {
			var selectionOffset = $("#selectionOffset")[0];
			selectionOffset.innerHTML = message;
		}
		
		function writeCoords(message) {
			var coords = $("#coords")[0];
			coords.innerHTML = message;
		}
		
		function writeHexCoords(message) {
			var hexCoords = $("#hexCoords")[0];
			hexCoords.innerHTML = message;
		}
		
		function writeUnitInfo(message) {
			var unitInfo = $("#unitInfo")[0];
			unitInfo.innerHTML = message;
		}
		
		</script>
</h:head>
<h:body>
	<div id="container">
		<div id="header">
			<h1>Zgame - Menschen. Zombies. Ende.</h1>
			<div style="float: right;">Join it. Play it. Love it.</div>
			<br />
			<div style="float: right;">- Lars</div>
		</div>
		<div id="content-container">
			<div id="aside0" class="sidebar">
				<div>
					<h3>Settings</h3>
					<h:panelGrid>
						<p>
							<h:panelGroup>
								<input id="rowsIn" style="text-align: center" type="text"
									placeholder="rows" maxlength="5" size="5" />
								<b>x</b>
								<input id="colsIn" style="text-align: center" type="text"
									placeholder="columns" maxlength="5" size="5" />
							</h:panelGroup>
						</p>
						<h:panelGrid columns="3">
							<input id="fSize" style="text-align: center" type="text"
								placeholder="size" maxlength="3" size="4" />
							<h:selectOneMenu id="type">
								<f:passThroughAttribute name="name" value="type" />
								<f:selectItem itemLabel="Flat" itemValue="0" />
								<f:selectItem itemLabel="Pointy" itemValue="1" />
							</h:selectOneMenu>
							<h:selectOneMenu id="direction">
								<f:passThroughAttribute name="name" value="direction" />
								<f:selectItem itemLabel="even" itemValue="0" />
								<f:selectItem itemLabel="odd" itemValue="1" />
							</h:selectOneMenu>
						</h:panelGrid>
						<p>
							<h:commandButton type="button" value="Render" onclick="update();" />
						</p>
					</h:panelGrid>
				</div>
				<div>
					<h3>Info</h3>
					<h:panelGrid>
						<p>
							<output id="coords" style="float: left;">
								<b>Mouse position:</b> n.a, n.a
							</output>
						</p>
						<p>
							<output id="selectionOffset" style="float: left;">
								<b>Selection offset:</b> n.a, n.a
							</output>
						</p>
						<p>
							<output id="hexCoords" style="float: left;">
								<b>Hex position:</b> n.a, n.a
							</output>
						</p>
						<p>
							<output id="unitInfo" style="float: left;">
								<b>Einheit:</b> n.a
							</output>
						</p>
					</h:panelGrid>
				</div>
			</div>
			<div id="content" align="center">
				<H1>MAP_TEST_4</H1>
				<h:form id="map_test_4">
					<h:messages id="msgs" errorStyle="color:red;" />
		
					<div style="overflow-x: scroll;overflow-y: scroll;">
						<canvas id="mapCanvas" height="1000" width="2100">Upgrade your browser!</canvas>
					</div>

				</h:form>
			</div>
		</div>
		<div id="footer">
			<footer>
				<p>
					<br />SPREAD OR SURVIVE.<br />
				</p>
				<div>Copyright Â© Site Lars-Christian Simon, 2013</div>
			</footer>
		</div>
	</div>
</h:body>
</html>